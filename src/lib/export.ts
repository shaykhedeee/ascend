// ═══════════════════════════════════════════════════════════════════════════════
// ASCEND - Data Export Utilities
// Export user data to JSON or PDF
// ═══════════════════════════════════════════════════════════════════════════════

import { format } from 'date-fns';

interface ExportData {
  user: any;
  habits: any[];
  habitEntries: any[];
  goals: any[];
  exportedAt: string;
  version: string;
}

/**
 * Export all user data to a JSON file
 */
export function exportToJSON(data: ExportData): void {
  const exportData = {
    ...data,
    exportedAt: new Date().toISOString(),
    version: '1.0.0',
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ascend-backup-${format(new Date(), 'yyyy-MM-dd')}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Import user data from a JSON file
 */
export async function importFromJSON(file: File): Promise<ExportData | null> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target?.result as string);
        
        // Validate the data structure
        if (!data.user || !data.habits || !data.goals) {
          throw new Error('Invalid backup file format');
        }
        
        resolve(data as ExportData);
      } catch {
        reject(new Error('Failed to parse backup file'));
      }
    };
    
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
}

/**
 * Export progress report to PDF
 */
export async function exportToPDF(
  user: any,
  habits: any[],
  goals: any[],
  _habitEntries: any[]
): Promise<void> {
  // Dynamic import to reduce initial bundle size
  const { jsPDF } = await import('jspdf');
  const { default: autoTable } = await import('jspdf-autotable');
  
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  
  // Title
  doc.setFontSize(24);
  doc.setTextColor(20, 184, 153); // ASCEND color
  doc.text('ASCEND', pageWidth / 2, 20, { align: 'center' });
  
  doc.setFontSize(12);
  doc.setTextColor(100);
  doc.text('Progress Report', pageWidth / 2, 28, { align: 'center' });
  doc.text(format(new Date(), 'MMMM d, yyyy'), pageWidth / 2, 35, { align: 'center' });
  
  // User Stats
  doc.setFontSize(16);
  doc.setTextColor(0);
  doc.text('Your Progress', 14, 50);
  
  doc.setFontSize(11);
  doc.setTextColor(60);
  doc.text(`Name: ${user.name}`, 14, 60);
  doc.text(`Level: ${user.gamification?.level || 1}`, 14, 67);
  doc.text(`Total XP: ${user.gamification?.totalXP || 0}`, 14, 74);
  doc.text(`Current Streak: ${user.stats?.currentStreak || 0} days`, 14, 81);
  doc.text(`Best Streak: ${user.stats?.bestStreak || 0} days`, 14, 88);
  
  // Active Habits Table
  if (habits.length > 0) {
    doc.setFontSize(16);
    doc.setTextColor(0);
    doc.text('Active Habits', 14, 105);
    
    const habitData = habits
      .filter(h => h.isActive)
      .map(h => [
        h.name,
        h.category || 'General',
        `${h.currentStreak || 0} days`,
        `${h.completedToday ? 'Yes' : 'No'}`,
      ]);
    
    autoTable(doc, {
      startY: 110,
      head: [['Habit', 'Category', 'Streak', 'Today']],
      body: habitData,
      theme: 'striped',
      headStyles: { fillColor: [20, 184, 153] },
    });
  }
  
  // Active Goals Table
  if (goals.length > 0) {
    const tableEndY = (doc as any).lastAutoTable?.finalY || 110;
    
    doc.setFontSize(16);
    doc.setTextColor(0);
    doc.text('Active Goals', 14, tableEndY + 15);
    
    const goalData = goals
      .filter(g => g.status === 'in_progress')
      .map(g => [
        g.title,
        g.category || 'General',
        `${g.progress || 0}%`,
        `${g.milestones?.filter((m: any) => m.status === 'completed').length || 0}/${g.milestones?.length || 0}`,
      ]);
    
    autoTable(doc, {
      startY: tableEndY + 20,
      head: [['Goal', 'Category', 'Progress', 'Milestones']],
      body: goalData,
      theme: 'striped',
      headStyles: { fillColor: [251, 189, 35] }, // Gold color
    });
  }
  
  // Footer
  const pageHeight = doc.internal.pageSize.getHeight();
  doc.setFontSize(8);
  doc.setTextColor(150);
  doc.text('Generated by ASCEND - Rise to your potential', pageWidth / 2, pageHeight - 10, { align: 'center' });
  
  // Save the PDF
  doc.save(`ascend-progress-${format(new Date(), 'yyyy-MM-dd')}.pdf`);
}

/**
 * Clear all localStorage data (reset app)
 * This clears both localStorage AND forces a full page reload
 * to reset in-memory Zustand state
 */
export function clearAllData(): Promise<void> {
  return new Promise((resolve) => {
    if (typeof window !== 'undefined') {
      // Clear the main store
      localStorage.removeItem('ascend-store');
      // Clear user session
      localStorage.removeItem('ascend-user');
      // Clear any other app-related data
      const keysToRemove = Object.keys(localStorage).filter(
        key => key.startsWith('ascend-')
      );
      keysToRemove.forEach(key => localStorage.removeItem(key));
      
      // Small delay to ensure storage is cleared
      setTimeout(resolve, 100);
    } else {
      resolve();
    }
  });
}

/**
 * Export all data from the Zustand store automatically
 * This is a convenience function that reads from localStorage
 */
export function exportAllData(): void {
  if (typeof window === 'undefined') return;

  try {
    // Get the stored data
    const storedData = localStorage.getItem('ascend-storage');
    if (!storedData) {
      console.warn('No data found to export');
      return;
    }

    const parsed = JSON.parse(storedData);
    const state = parsed?.state || parsed;

    // Create export data structure
    const exportData: ExportData = {
      user: state.user || {},
      habits: state.habits || [],
      habitEntries: state.habitEntries || [],
      goals: state.goals || [],
      exportedAt: new Date().toISOString(),
      version: '1.0.0',
    };

    // Include additional data if available
    const additionalData: Record<string, unknown> = {};
    if (state.taskLists) additionalData.taskLists = state.taskLists;
    if (state.habitStacks) additionalData.habitStacks = state.habitStacks;
    if (state.timedTasks) additionalData.timedTasks = state.timedTasks;
    if (state.pomodoroSessions) additionalData.pomodoroSessions = state.pomodoroSessions;
    if (state.coachMessages) additionalData.coachMessages = state.coachMessages;

    const fullExportData = {
      ...exportData,
      ...additionalData,
    };

    // Create and download the file
    const blob = new Blob([JSON.stringify(fullExportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ascend-backup-${format(new Date(), 'yyyy-MM-dd-HHmm')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log('Data exported successfully');
  } catch (error) {
    console.error('Failed to export data:', error);
  }
}

/**
 * Export habit data to CSV format
 */
export function exportToCSV(
  habits: any[],
  habitEntries: any[],
  goals: any[]
): void {
  const rows: string[][] = [];
  
  // Habit entries section
  rows.push(['=== HABIT ENTRIES ===']);
  rows.push(['Date', 'Habit', 'Category', 'Completed', 'Streak']);
  
  const habitsMap = new Map(habits.map(h => [h.id, h]));
  
  // Sort entries by date descending
  const sortedEntries = [...habitEntries].sort((a, b) => b.date.localeCompare(a.date));
  
  for (const entry of sortedEntries) {
    const habit = habitsMap.get(entry.habitId);
    if (!habit) continue;
    rows.push([
      entry.date,
      habit.name,
      habit.category || 'General',
      entry.completed ? 'Yes' : 'No',
      String(habit.currentStreak || 0),
    ]);
  }
  
  rows.push([]);
  rows.push(['=== GOALS ===']);
  rows.push(['Title', 'Status', 'Progress', 'Category', 'Target Date', 'Milestones Completed']);
  
  for (const goal of goals) {
    const completedMilestones = goal.milestones?.filter((m: any) => m.status === 'completed').length || 0;
    const totalMilestones = goal.milestones?.length || 0;
    rows.push([
      goal.title,
      goal.status,
      `${goal.progress || 0}%`,
      goal.category || 'General',
      goal.targetDate ? format(new Date(goal.targetDate), 'yyyy-MM-dd') : 'None',
      `${completedMilestones}/${totalMilestones}`,
    ]);
  }
  
  rows.push([]);
  rows.push(['=== HABITS SUMMARY ===']);
  rows.push(['Name', 'Category', 'Frequency', 'Current Streak', 'Longest Streak', 'Active']);
  
  for (const habit of habits) {
    rows.push([
      habit.name,
      habit.category || 'General',
      habit.frequency || 'daily',
      String(habit.currentStreak || 0),
      String(habit.longestStreak || 0),
      habit.isActive ? 'Yes' : 'No',
    ]);
  }
  
  // Convert to CSV string
  const csvContent = rows
    .map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
    .join('\n');
  
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ascend-data-${format(new Date(), 'yyyy-MM-dd')}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
